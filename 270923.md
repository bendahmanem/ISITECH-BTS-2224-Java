# JAVA (jour 3)

## Programmation orientée objet

Les classes sont constituees de:

- champs
- methodes

Il y a trois concepts cles qu'il faudra bien comprendre d'ici la fin de la semaine:

- Encapsulation
- Heritage
- Polymorphisme

### Encapsulation

L’encapsulation consiste à cacher les éléments qui ne sont pas nécessaires pour l’utilisation d’un objet. Cette technique permet de garantir que l’objet sera correctement utilisé. C’est un principe qui est aussi largement utilisé dans d’autres domaines que l’informatique. Pour reprendre l’exemple de l’industrie automobile, savez-vous comment fonctionne la boîte de vitesses de votre voiture ?

Les elements visibles depuis l'exterieur de la classe sont appelés l'interface de la classe.

### L'heritage

L'heritage permet de creer une classe a partir d'une autre classe. La classe heritee est appelee la classe mere(ou classe de base, ou superclass), la classe qui herite est appelee la classe fille (derivee ou encore sous classe).

### Polymorphisme

Le polymorphisme permet d'utiliser plusieurs classes differentes de facon interchangeable dans un programme.  
Ce concept est souvent accompagne de deux autres concepts: la surcharge et la substitution.

## En java...

Les classes sont representees sous forme de diagramme UML (Unified Modeling Language).

https://www.uml.org/
https://www.tutorialspoint.com/uml/index.htm
https://en.wikipedia.org/wiki/Unified_Modeling_Language

UML est un langage graphique qui permet de representer les concepts de la POO.

### La creation d'une clasee :

La création d’une classe passe par la déclaration de la classe elle-même et de tous les éléments la constituant.

#### La declaration d'une classe

```java

    [modificateurs] class NomDeLaClasse  [extends NomDeLaClasseDeBase]  [implements NomDeInterface1,NomDeInterface2,...]  {
        Code de la classe
    }

```

La déclaration d’une classe se fait en utilisant le mot-clé class suivi du nom de la classe puis d’un bloc de code délimité par les caractères { et }. Dans ce bloc de code, on trouve des déclarations de variables qui seront les champs de la classe et des fonctions qui seront les méthodes de la classe. Plusieurs mots-clés peuvent être ajoutés pour modifier les caractéristiques de la classe.

#### Les modificateurs

Ils permetttent de modifier la visibilite de la classe. Il y a plusieurs modificateurs :

- public : indique que la classe peut être utilisée par toutes les autres classes. Sans ce modificateur, la classe ne sera utilisable que par les autres classes faisant partie du même package.

- private : indique que la classe ne peut être utilisée que par les autres classes faisant partie du même package.

- protected : indique que la classe ne peut être utilisée que par les autres classes faisant partie du même package ou par les classes filles de cette classe.

#### Les autres modificateurs

- package : indique que la classe ne peut être utilisée que par les autres classes faisant partie du même package. Ce modificateur est implicite, c’est-à-dire qu’il est utilisé par défaut si aucun autre modificateur n’est spécifié.

- abstract : indique que la classe est une classe abstraite. Une classe abstraite ne peut pas être instanciée. Elle ne peut être utilisée que comme classe de base pour d’autres classes.

- final : indique que la classe ne peut pas être utilisée comme classe de base pour d’autres classes.

```java
    public class Personne {
            // ... contenu de la classe
    }
```

#### Les champs

La creation de champs fait une syntaxe particuliere:

```java
    [private | protected | public] typeDeLaVariable nomDeLaVariable;
```

Sachez qu'il est possible de creer des variables de classe avec le mot `static` et des constantes avec `final`.

```java
    public class Personne {
        private String nom;
        private String prenom;
        private int age;
        private static int nombreDePersonnes = 0;
        private final String pays = "France";
        // ... contenu de la classe
    }
```

Les portees :

- private : la variable est visible uniquement dans la classe
- protected : la variable est visible dans la classe et dans les classes filles, ainsi que dans le package
- public : la variable est visible partout

Si vous oubliez de preciser une portee, la portee par defaut est package.

#### Les methodes

Voici la syntaxe de creation de methodes en Java

```java
    [modificateurs] typeRetour nomMethode ([listeParametres])
                                      [throws listeException]
    {

    }
```

Les modificateurs de visibilite sont les memes que pour les champs:

- private:
- protected:
- public:

Des modificateurs supplementaires sont disponibles:

- static : indique que la methode est une methode de classe. Une methode de classe peut être appelée sans avoir besoin d’instancier la classe.
- abstract : indique que la méthode est une méthode abstraite. Une méthode abstraite ne contient pas de code et doit être redéfinie dans les classes filles.
- final: indique que la méthode ne peut pas être redéfinie dans les classes filles.
- native: indique que la methode se trouve dans un fichier externe ecrit dans un autre langage que java.
- synchronized: indique que la methode ne peut etre execute que par un seul thread.

```java
    public class Personne {
        private String nom;
        private String prenom;
        private int age;
        private static int nombreDePersonnes = 0;
        private final String pays = "France";
        private LocalDate dateDeNaissance;

        public Personne(String nom, String prenom, int age) {
            this.nom = nom;
            this.prenom = prenom;
            this.age = age;
            nombreDePersonnes++;
        }

        public String getNom() {
            return nom;
        }

        public void setNom(String nom) {
            this.nom = nom;
        }

        public String getPrenom() {
            return prenom;
        }

        public void setPrenom(String prenom) {
            this.prenom = prenom;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        public static int getNombreDePersonnes() {
            return nombreDePersonnes;
        }

        public static void setNombreDePersonnes(int nombreDePersonnes) {
            Personne.nombreDePersonnes = nombreDePersonnes;
        }

        public String getPays() {
            return pays;
        }

        public String toString() {
            return "Personne [nom=" + nom + ", prenom=" + prenom + ", age=" + age + "]";
        }

        public int calculerAge() {
            if (dateDeNaissance != null) {
                return  dateDeNaissance.until(LocalDate.now()).getYears();
            } else {
                return 0;
            }
        }


    }
```

#### Creation d'accesseurs (getter et setter)

La déclaration des attributs avec une visibilité privée est une bonne pratique pour respecter le principe d’encapsulation. Toutefois, cette solution est limitative puisque seul le code de la classe où ils sont déclarés peut y accéder. Pour pallier ce problème, vous devez mettre en place des accesseurs. Ce sont des fonctions ordinaires qui ont simplement pour but de rendre visibles les champs à partir de l’extérieur de la classe. Par convention, les fonctions chargées d’affecter une valeur à un champ sont nommées set suivi du nom du champ, les fonctions chargées de fournir la valeur d’un champ sont nommées get suivi du nom du champ. Si le champ est de type boolean, le préfixe get est remplacé par le préfixe is. Si un champ doit être en lecture seule, l’accesseur set ne doit pas être disponible, si un champ doit être en écriture seule alors c’est la fonction get qui doit être omise. Les accesseurs sont communément appelés getters et setters.
Avec cette technique, vous pouvez contrôler l’utilisation qui sera faite des champs d’une classe. Nous pouvons donc modifier la classe Personne en y ajoutant quelques règles de gestion :

Le nom doit être en majuscules.

Le prénom doit être en minuscules.

```java
class Personne
{
    private String nom;
    private String prenom;

    public String getNom() {
        return nom;
    }

    public void setNom(String nom) {
        this.nom = nom.toUpperCase();
    }
}
```

### Les constructeurs

```java
class Personne {
    //...
    public Personne() {
        //...
    }
}

Personne ayoub = new Personne();


```

#### Les packages

Le but principal des packages est l’organisation et le rangement des classes et interfaces d’une application. Le principe est le même que dans la vie courante. Si vous avez un grand placard dans votre maison, il est évident que l’installation d’étagères dans ce placard va faciliter l’organisation et la recherche des objets qui y sont rangés par rapport à un stockage en "vrac". L’organisation des classes en packages apporte les avantages suivants :

Facilité pour retrouver et réutiliser un élément.

Limitation des risques de conflits de noms.

Création d’une nouvelle visibilité (la visibilité package) en plus des visibilités standards (private, protected, public). Lorsqu’un élément (une classe, un champ, une méthode) ne présente pas de modificateurs de visibilité, alors cet élément n’est visible que par les éléments présents dans le même package. Il existe une subtilité pour les éléments protégés (champs, méthodes). Ils sont bien sûr accessibles dans les classes dérivées, mais aussi dans les classes du même package.

Comment créer un package ?

La première chose à faire lorsque l’on souhaite créer un package est de lui trouver un nom. Ce nom doit être choisi avec précaution pour permettre au package de remplir pleinement son rôle. Il doit être unique et représentatif des éléments stockés à l’intérieur.

Pour assurer l’unicité du nom d’un package, on utilise par convention le nom de domaine de l’entreprise en inversant l’ordre des éléments comme première partie pour le nom du package.

```java
    isitech.fr
    fr.isitech

    ecole-isitech.fr

    fr.ecole_isitech.compta.Client

    fr.ecole_isitech.reseau.Client
```

Pour importer la classe Client dans une autre classe, il faut utiliser l’instruction import.

```java
    import fr.ecole_isitech.compta.Client;

    import fr.ecole_isitech.compta.*;

    import fr.*;
```

## Les generiques

Les classes generiques

Voici l'exemple d'une classe generique

```java
public class ListeGenerique <E>
{
   // pour stocker les éléments de la liste
   private ArrayList<E> liste;
   // pointeur de position dans la liste
   private int position;
   // nombre d'éléments de la liste
   private int nbElements;
   // constructeur avec un paramètre permettant de dimensionner
   // la liste
   public ListeGenerique(int taille)
   {
       liste=new ArrayList<E>(taille);
   }
   public void ajout(E element)
   {
       liste.add(element);
       nbElements = nbElements + 1;
   }
   public void insert(E element,int index)
   {
       // on vérifie si l'index n'est pas supérieur au nombre
       // d'éléments ou si l'index n'est pas inférieur à 0
       if (index >= nbElements || index < 0)
       {
          return;
       }
       liste.add(index,element);
       // on met à jour le nombre d'éléments
       nbElements = nbElements + 1;
   }

   public void remplace(E element,int index)
   {
       // on vérifie si l'index n'est pas supérieur au nombre
       // d'éléments ou si l'index n'est pas inférieur à 0
       if (index >= nbElements || index < 0)
       {
          return;
       }
       liste.set(index,element);
   }
   public void supprime(int index)
   {
       int i;
       // on vérifie si l'index n'est pas supérieur au nombre
       // d'éléments ou si l'index n'est pas inférieur à 0
       if (index >= nbElements || index < 0)
       {
          return;
       }
       liste.remove(index);
       // on met à jour le nombre d'éléments
       nbElements = nbElements - 1;
   }
   public E getElement(int j)
   {
      return liste.get(j);
   }
   public int getNbElements()
   {
       return nbElements;
   }
   public E premier() throws Exception
   {
       if (nbElements == 0)
       {
           throw new Exception("liste vide");
       }
       // on déplace le pointeur sur le premier élément
       position = 0;
       return liste.get(0);
   }
   public E dernier() throws Exception
   {
       if (nbElements == 0)
       {
           throw new Exception("liste vide");
       }
       // on déplace le pointeur sur le dernier élément
       position = nbElements - 1;
       return liste.get(position);
   }
   public E suivant() throws Exception
   {
       if (nbElements == 0)
       {
           throw new Exception("liste vide");
       }
       // on vérifie si on n'est pas à la fin de la liste
       if (position == nbElements - 1)
       {
           throw new Exception("pas d'element suivant");
       }
       // on déplace le pointeur sur l'élément suivant
       position = position + 1;
       return liste.get(position);
   }
   public E precedent() throws Exception
   {
       if (nbElements == 0)
       {
           throw new Exception("liste vide");
       }
       // on vérifie si on n'est pas sur le premier élément
       if (position == 0)
       {
           throw new Exception("pas d'élément précédent");
       }
       // on se déplace sur l'élément précédent
       position = position - 1;
       return liste.get(position);
   }
}
```

Voici un exemple d'utilisation de la classe generique decrite precedemment:

    ```java
        ListeGenerique<String> liste = new ListeGenerique<String>(10);
    ```
